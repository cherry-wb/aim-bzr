<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on http://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen"/>
  <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>AIM</title>
  <meta name="description" content="Artificial Intelligence Modules">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">AIM</h1>
    </header>
    <div id="container">
      <p class="tagline">Artificial Intelligence Modules</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
<!--          <a href="https://github.com/mrquincle/aim-bzr/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/mrquincle/aim-bzr/zipball/master" class="download-button zip"><span>Download</span></a>
-->
          <a href="https://github.com/mrquincle/aim-bzr" class="code">View AIM on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <h3>Welcome to AIM</h3>

<p>
AIM stands for Artificial Intelligence Modules, but is much more than that. AIM is inspired by three recent movements in practical computer science. First, in the robotics community there is a need for a wide range of functionalities, from computer vision, navigation and mapping, to sensor fusion, and machine learning, which lead to several frameworks that allow people to collaborate: <a href="http://eris.liralab.it/yarp">YARP</a> (Yet Another Robot Platform), <a href="http://www.ros.org">ROS</a> (Robot Operating System), <a href="http://www.urbiforge.org">URBI</a> (Universal Real-time Behavior Interface) to name a few. Second, there are market infrastructures to distribute your applications: <a href="https://play.google.com">Google play</a>, <a href="http://www.apple.com/iphone/from-the-app-store/">Apple app store</a>, and let's hope also an online presence later of the excellent package managers like apt-get in the form of the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad package archives</a> and the <a href="https://build.opensuse.org/">openSUSE build service</a>. Third, there are frameworks to allow you to implement or reveal functionality in the cloud, from <a href="http://www.zeromq.org/">ZeroMQ</a>, a distributed transport layer used in Twitter <a href="http://storm-project.net/">Storm</a>, to <a href="http://mahout.apache.org/">Mahout</a>, scalable Map/Reduce based machine learning libraries. </p>

<h3>Goal</h3>
<p>
The goal of AIM is threefold:
<ul>
<li>A <b>middleware-agnostic</b> modular approach to writing code: the "rur-builder". 
<li>A <b>distributed market place</b>: the "aimserver".
<li>Software that is inherently <b>scalable and runs on servers</b> as smoothly as one robots or smartphones.
</ul>

</p>

<h3>Components</h3>
<p>
The <b>rur-builder</b> is loosely similar to <a href="http://homepages.laas.fr/mallet/soft/architecture/genom3">Genom3</a>. It does not create some additional library that has to be linked to all middlewares from YARP, ROS, to URBI, instead it uses a code generator, that generates dedicated interface files. However, different from Genom3 the code is not "enriched" with meta-information. The meta-information is by virtue of a specific IDL file, that describes the interface of a module in a general sense. This means that code completion still works: there are no tcl-statements through the code that makes indexing difficult.</p>

<p>
The current rur-builder provides functionality for different backends. Currently supported are <b>YARP</b>, <b>ROS</b>, and <b>ZeroMQ</b> as middleware between the different AI modules. To be able to use ZeroMQ as middleware solution a nameserver is implemented, called "zmqserver", and "zmqconnect", a connect utility (allowing exogenous coordination: start two modules separately and only later on connect them together).
</p>

<p>
The <b>aimserver</b> (forthcoming) is a REST server that allows people to find AI modules across a wide range of repositories. Moreover, it provides functionality to compile the code found, run it, stop it, and connect modules together. Towards that purpose there is a range of tools to create, register, copy, and connect AI modules: "aimtools".
</p>

<h3>Example</h3>
<p>
At <a href="https://github.com/mrquincle/aim_modules">AIM modules</a> you can find a ReadModule and a WriteModule that show how this framework operates. Both modules come with an IDL file (IDL stands for Interface Description Language). The <a href="https://raw.github.com/mrquincle/aim_modules/master/ReadModule/aim/idl/ReadModule.idl">IDL file</a> of the ReadModule does actually have only a few lines:</p>

<p>
<pre><code>#pragma copyright LGPLv3

// Recommended namespace "rur"
module rur {

// We want to be able to give our class a name
interface ReadModule {

  // Input from sensor as individual values
  void Input(in long input);

};
</code></pre>
</p>

<p>
The important part here is the function "void Input" defined with an additional keyword: "in". This is transformed in a function description of which the following one shows the YARP-specific one:
</p>
<p><pre><code>inline int *readInput(bool blocking=true) {
  Bottle *b = portInput->read(blocking);
  if (b != NULL) { 
    portInputValue = b->get(0).asInt();
    return &portInputValue;
  }
  return NULL;
}
</code></pre></p>

<p>
As you can see the generated code suddenly uses concepts that only mean something in YARP, such as an object called the "Bottle". You do not need to know anything about these if you are just using the function readInput(), which is exactly what is meant by AIM allowing you to write middleware-agnostic code. The other parts of the code also appear in the generated header file (not shown). The #pragma statements for example are transformed into comments and meant for author, copyright, date, and license information in the header.  The "module" keyword translates into a namespace.
</p>

<p>
Now, the running of the code of these modules actually depends on the middleware of course. Let us assume you installed the framework by using the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad PPA</a> (see below). This means you can install YARP by apt-get. Let us assume you downloaded the AI modules to $AIM_MODULES_PATH. Then to run the modules with YARP middleware, you will need to:
</p>

<p><pre><code>sudo apt-get install libyarp libyarp-dev yarp-bin
cd $AIM_MODULES_PATH/ReadModule 
echo "set(BUILD_YARP on)" >> aim/local.cmake
make
cd $AIM_MODULES_PATH/WriteModule 
echo "set(BUILD_YARP on)" >> aim/local.cmake
make
cd $AIM_MODULES_PATH
aimregister ReadModule
aimregister WriteModule
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
yarp server
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect yarp WriteModule 0 output ReadModule 0 input
</code></pre></p>

<p>
This will use the YARP middleware to set up a TCP connection between the WriteModule and the ReadModule to send over a value. The "connect" utility needs to know which middleware is used, on the moment it will require a server to be run on the machine, but this requirement can be lifted for a distributed environment, as long as the specific "connect" implementations of the middleware knows how to find the registered ports.
</p>

<h3>How to get it?</h3>
<p>
You can get the code from <a href="https://github.com/mrquincle/aim-bzr">github.com</a>, but the easiest way to get the code is via <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad</a>:

<pre><code>sudo add-apt-repository ppa:dobots/ppa 
sudo apt-get update
sudo apt-get install aim
dpkg -L aim</code></pre></p>

<h3>Support</h3>

<p>You would like to know more? Check out the company providing all this open-source software <a href="http://www.dobots.nl">Distributed Organisms B.V.</a>, a spinoff of the Dutch research institute <a href="http://www.almende.com">Almende</a>. You can also checkout the repositories of individual authors <a href="https://github.com/vliedel" class="user-mention">Bart van Vliet</a>, <a href="https://github.com/eggerdo" class="user-mention">Dominik Egger</a> and <a href="https://github.com/mrquincle" class="user-mention">Anne van Rossum</a>.</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/mrquincle" class="avatar"><img src="https://secure.gravatar.com/avatar/36365a1f813c2fe401024f5d3552adaf?s=30&amp;d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png" width="48" height="48"/></a> <a href="https://github.com/mrquincle">mrquincle</a> maintains <a href="https://github.com/mrquincle/aim-bzr">AIM</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br/>theme by <a href="http://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
<!--
    <a href="https://github.com/mrquincle/aim-bzr/tarball/master" class="tar">tar</a><a href="https://github.com/mrquincle/aim-bzr/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
-->
    <p class="name"></p>
  </div>

  
</body>
</html>
