<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on http://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen"/>
  <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>AIM</title>
  <meta name="description" content="Artificial Intelligence Modules">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">AIM</h1>
    </header>
    <div id="container">
      <p class="tagline">Artificial Intelligence Modules</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
<!--          <a href="https://github.com/mrquincle/aim-bzr/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/mrquincle/aim-bzr/zipball/master" class="download-button zip"><span>Download</span></a>
-->
          <a href="https://github.com/mrquincle/aim-bzr" class="code">View AIM on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <h3>Welcome to AIM</h3>

<p>
AIM stands for Artificial Intelligence Modules, but is much more than that. AIM is inspired by three recent movements in practical computer science. First, in the robotics community there is a need for a wide range of functionalities, from computer vision, navigation and mapping, to sensor fusion, and machine learning, which lead to several frameworks that allow people to collaborate: <a href="http://eris.liralab.it/yarp">YARP</a> (Yet Another Robot Platform), <a href="http://www.ros.org">ROS</a> (Robot Operating System), <a href="http://www.urbiforge.org">URBI</a> (Universal Real-time Behavior Interface) to name a few. Second, there are market infrastructures to distribute your applications: <a href="https://play.google.com">Google play</a>, <a href="http://www.apple.com/iphone/from-the-app-store/">Apple app store</a>, and repositories like the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad package archives</a> and the <a href="https://build.opensuse.org/">openSUSE build service</a>. Third, there are frameworks to allow you to implement or reveal functionality in the cloud, from <a href="http://www.zeromq.org/">ZeroMQ</a>, a distributed transport layer used in Twitter <a href="http://storm-project.net/">Storm</a>, to <a href="http://mahout.apache.org/">Mahout</a>, scalable Map/Reduce based machine learning libraries. </p>

<h3>Goal</h3>
<p>
The goal of AIM is threefold:
<ul>
<li>A <b>middleware-agnostic</b> modular approach to writing code: the <b>rur-builder</b>.</li>
<li>Tools to easily <b>create, publish, and cross-compile modules</b> that run as smoothly on robots as on servers: the <b>aimtools</b>.</li>
<li>A <b>distributed market place</b>, an app store for web developers: the <b>aimserver</b>.</li>
</ul>

</p>

<h3>Components</h3>
<p>
The <b>rur-builder</b> is loosely similar to <a href="http://homepages.laas.fr/mallet/soft/architecture/genom3">Genom3</a>. Just as Genom3 it is aimed to create an infrastructure of blocks of software that somehow know how to talk to each other. Genom3 and the rur-builder does not create some additional library that has to be linked to all middlewares (YARP, ROS, URBI, AgentScape, ZeroMQ) which quickly becomes a pain. In contrary, Genom3 and the rur-builder perform code generation. However, different from Genom3 using the rur-builder does not actually change the code itself. We do not "enrich" the code with meta-information. The meta-information is expected to be written down in a specific IDL file. This IDL file describes the interface of a module in a general sense. This means for example (contrary to Genom3) that code completion still works: there are no meta-statements (in TCL) through the code. This has multiple advantages. a.) The indexer just works. b.) A standard backend can be used for prototyping, not requiring any middleware. c.) Code generation in the headers can be extremely flexible, e.g. implementing topics for ROS, a concept totally absent in YARP. This is hard to achieve this flexibility by meta-statements in the code itself.</p>

<p>
The current rur-builder provides functionality for different backends. Currently supported are <b>YARP</b>, <b>ROS</b>, and <b>ZeroMQ</b> as middleware between the different AI modules. To be able to use ZeroMQ as middleware solution a nameserver is implemented, called "zmqserver", and "zmqconnect", a connect utility (allowing exogenous coordination: start two modules separately and only later on connect them together).
</p>

<p>
The <b>aimtools</b> is a suite of tools in the same spirit as some of the tools in ROS, such as roscreate-pkg:
<ul>
<li><b>aimget</b>: add a github repository to your AIM workspace</li>
<li><b>aimcreate-pkg</b>: create a new AI module</li>
<li><b>aimregister</b>: register the module locally</li>
<li><b>aimselect</b>: select a specific middleware to compile for</li>
<li><b>aimmake</b>: compile the module</li>
<li><b>aimcross</b>: cross-compile the module (currently supported: blackfin; upcoming: raspberry)</li>
<li><b>aimrun</b>: run a previously registered module</li>
<li><b>aimconnect</b>: connect two ports on running modules</li>
<li><b>aimstop</b>: register the module locally</li>
</ul>
</p>

<p>
The <b>aimserver</b> (forthcoming) is a REST server that allows people to find AI modules across a wide range of repositories. Moreover, it provides functionality to compile the code found, run it, stop it, and connect modules together. Towards that purpose there is a range of tools to create, register, copy, and connect AI modules: "aimtools".
</p>

<h3>Example</h3>
<p>
At <a href="https://github.com/mrquincle/aim_modules">AIM modules</a> you can find a ReadModule and a WriteModule that show how this framework operates. Both modules come with an IDL file (IDL stands for Interface Description Language). The <a href="https://raw.github.com/mrquincle/aim_modules/master/ReadModule/aim/idl/ReadModule.idl">IDL file</a> of the ReadModule does actually have only a few lines:</p>

<p>
<pre><code>#pragma copyright LGPLv3

// Recommended namespace "rur"
module rur {

// We want to be able to give our class a name
interface ReadModule {

  // Input from sensor as individual values
  void Input(in long input);

};
}</code></pre></p>

<p>
The important part here is the function "void Input" defined with an additional keyword: "in". This is transformed in a function description of which the following one shows the YARP-specific one:
</p>
<p><pre><code>inline int *readInput(bool blocking=true) {
  Bottle *b = portInput->read(blocking);
  if (b != NULL) { 
    portInputValue = b->get(0).asInt();
    return &portInputValue;
  }
  return NULL;
}</code></pre></p>

<p>
As you can see the generated code suddenly uses concepts that only mean something in YARP, such as an object called the "Bottle". You do not need to know anything about these if you are just using the function readInput(), which is exactly what is meant by AIM allowing you to write middleware-agnostic code. The other parts of the code also appear in the generated header file (not shown). The #pragma statements for example are transformed into comments and meant for author, copyright, date, and license information in the header.  The "module" keyword translates into a namespace.
</p>

<h4>Get the rur-builder and the aimtools</h4>
<p>A default repository is available with modules mainly filled from <a href="http://almende.github.com/nets/">NETS</a> comprising computer vision, machine learning, prediction modules. Let us assume here we have a generic Linux version. In case of Ubuntu you can better use the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad PPA</a>! With other Linux versions you can manually get the software by:
</p>

<p><pre><code>mkdir $HOME/aim
cd $HOME/aim
git clone https://github.com/mrquincle/rur-builder
cd rur-builder
make
sudo make install
cd $HOME/aim
git clone https://github.com/mrquincle/aimtools
cd aimtools
make
sudo make install
</code></pre></p>

<p>Do this for all subprojects in <a href="https://github.com/mrquincle/aim-bzr">aim-bzr</a> that you want to use.</p> You should now have rur-builder, aimcreate-pkg, etc. installed on your system. Check that typing "rur-builder -h" results in a nice help message for example. Please, notice that you will manually have to install required dependencies (because you did not use the PPA), such as <b>sudo apt-get install omniidl</b> and the several middlewares (such as zeromq, yarp, and ros). 
</p>

<h4>Get some modules</h4>

<p>To download the module repository we use aimget:</p>
<pre><code>mkdir -p $HOME/workspace/aim
echo "export AIM_WORKSPACE=$HOME/workspace/aim >> $HOME/.bashrc"
source $HOME/.bashrc
aimget dobots https://github.com/mrquincle/aim_modules
cd $AIM_WORKSPACE</code></pre></p>

<p>Choose your workspace where you want of course, but this is how you will get started. Now you have downloaded a bunch of modules that you subsequently can compile and run in different ways.</p>

<h4>Example with YARP</h4>

<p>
Now, the running of the code of these modules actually depends on the middleware of course. Let us assume you installed the framework by using the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad PPA</a> (see below). This means you can install YARP by apt-get. Let us assume you downloaded the AI modules to $AIM_MODULES_PATH. Then to run the modules with YARP middleware, you will need to:
</p>

<p><pre><code>sudo apt-get install libyarp libyarp-dev yarp-bin
cd $AIM_MODULES_PATH
aimselect ReadModule yarp
aimmake ReadModule
aimregister ReadModule
aimselect WriteModule yarp
aimmake WriteModule
aimregister WriteModule
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
yarp server
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect yarp WriteModule 0 output ReadModule 0 input
</code></pre></p>

<p>
This will use the YARP middleware to set up a TCP connection between the WriteModule and the ReadModule to send over a value. The "connect" utility needs to know which middleware is used, on the moment it will require a server to be run on the machine, but this requirement can be lifted for a distributed environment, as long as the specific "connect" implementations of the middleware knows how to find the registered ports.
</p>

<h4>Example with ZeroMQ</h4>

<p>
Running the code with ZeroMQ instead of YARP is along similar lines. To run the same WriteModule and ReadModule with ZeroMQ, you will need to:
</p>

<p><pre><code>sudo apt-get install libzmq-dev
sudo apt-get install libjson-spirit-dev
cd $AIM_MODULES_PATH
aimselect ReadModule zeromq
aimmake ReadModule
aimregister ReadModule  # if not done before
aimselect WriteModule zeromq
aimmake WriteModule
aimregister WriteModule # if not done before
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
zmqserver
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect zmq WriteModule 0 output ReadModule 0 input
</code></pre></p>

<p>
Like you can see there is a almost no different with the YARP example, but now there is suddenly made use of ZeroMQ channels rather than YARP ones. The difference exists out of starting the right name server "zmqserver" rather than "yarp server", and run aimconnect with "zmq" instead of "yarp".
</p>

<h3>Create your own module</h3>

<p>
So, how to go about to create your own module? Suppose we want to create a module that receives a value on an input port and sends a moving average on its output port.
</p>

<p><pre><code>cd $AIM_MODULES_PATH
aimcreate-pkg MovingAverageModule
cd $AIM_MODULES_PATH/MovingAverageModule
# Now we compile our module, the default module already compiles!
make</code></pre></p>

<p>
We are now going to make our changes to the code at three places. Open $AIM_MODULES_PATH/MovingAverageModule/aim/idl/MovingAverageModule.idl with your favorite editor and make sure the interface definition looks like the following:
</p>

<p><pre><code>interface MovingAverageModule {
  void Input(in long input);
  
  void Average(out long output);
}</code></pre></p>

<p>
Adjust $AIM_MODULES_PATH/MovingAverageModule/aim/inc/MovingAverageModuleExt.h to just add two private fields to the class (to count the messages, and to store the last average):
</p>

<p><pre><code>class MovingAverageModuleExt: public MovingAverageModule {
public:
  MovingAverageModuleExt(): message_counter(0), prev_average(0) { }
  void Tick();
  bool Stop();
private:
  long int message_counter;
  double prev_average;
};
</code></pre></p>

<p>
Adapt $AIM_MODULES_PATH/MovingAverageModule/src/MovingAverageModuleExt.cpp subsequently:
</p>

<p>
<pre><code>void MovingAverageModuleExt::Tick() {
  MovingAverageModule::Tick();
  int *value = readInput();
  if (value) {
    int i = ++message_counter;
    double average = (*value + prev_average*(i-1)) / i;
	    writeAverage(average);
    prev_average = average;
  }
  sleep(1);
}</code></pre>
</p>

<p>
You can see that there is a call to the parent Tick() function, this is important to be able to receive messages. The complete code you can find at the <a href="https://github.com/mrquincle/aim_modules/blob/master/MovingAverageModule/src/MovingAverageModuleExt.cpp">MovingAverageModuleExt.cpp</a> on github. Running your example is in the same way as defined with the ReadModule and WriteModule example. Let us use the ZeroMQ backend (and assume that you followed the example above with the ReadModule and the WriteModule currently compiled for the ZeroMQ backend indeed):
</p>

<p><pre><code>cd $AIM_MODULES_PATH/MovingAverageModule 
echo "set(BUILD_ZEROMQ on)" > aim/local.cmake
make
cd $AIM_MODULES_PATH
aimregister MovingAverageModule
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
zmqserver
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun MovingAverageModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect zeromq MovingAverageModule 0 average ReadModule 0 input
aimconnect zeromq WriteModule 0 output MovingAverageModule 0 input
</code></pre></p>

<p>
The output you can expect in the terminal with the MovingAverageModule (use Ctrl+Page Up/Down to navigate) is something like: "Messages received: 4" and "Calculate (666+666*3)/4=666". Do not forget to upload your code now to your own github repository!
</p>

<p><pre><code>cd $AIM_MODULES_PATH/MovingAverageModule 
rm aim/local.cmake
make clean
cd $AIM_MODULES_PATH
git add MovingAverageModule
git commit -m "A moving average module for the AIM repository"
git push
</code></pre></p>

<p>
As you can see we cleaned up beforehand and we removed the "aim/local.cmake" file that indicates your own preference for a middleware. If a certain module has a specific preferred middleware you can indicate this in the "aim/default.cmake" file.
</p>

<h3>How to get it?</h3>
<p>
You can get the code from <a href="https://github.com/mrquincle/aim-bzr">github.com</a>, but the easiest way to get the code is via <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad</a>:

<pre><code>sudo add-apt-repository ppa:dobots/ppa 
sudo apt-get update
sudo apt-get install aim
dpkg -L aim</code></pre></p>

<h3>Support</h3>

<p>You would like to know more? Check out the company providing all this open-source software <a href="http://www.dobots.nl">Distributed Organisms B.V.</a>, a spinoff of the Dutch research institute <a href="http://www.almende.com">Almende</a>. You can also checkout the repositories of individual authors <a href="https://github.com/vliedel" class="user-mention">Bart van Vliet</a>, <a href="https://github.com/eggerdo" class="user-mention">Dominik Egger</a> and <a href="https://github.com/mrquincle" class="user-mention">Anne van Rossum</a>.</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/mrquincle" class="avatar"><img src="https://secure.gravatar.com/avatar/36365a1f813c2fe401024f5d3552adaf?s=30&amp;d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png" width="48" height="48"/></a> <a href="https://github.com/mrquincle">mrquincle</a> maintains <a href="https://github.com/mrquincle/aim-bzr">AIM</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br/>theme by <a href="http://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
<!--
    <a href="https://github.com/mrquincle/aim-bzr/tarball/master" class="tar">tar</a><a href="https://github.com/mrquincle/aim-bzr/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
-->
    <p class="name"></p>
  </div>

  
</body>
</html>
