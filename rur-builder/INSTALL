RUR Platform
The company DO makes use of the RUR platform, the Roughly Universal Robot platform. In robotic communities there are many robotic platforms available: ROS, YARP, MARIE, ACT-R, SOAR, IDA. The former concentrating on providing middleware functionalities like connectors, ports, messages and a hardware abstraction layer, the latter focusing on (cognitive) control architectures, a dynamic set of functional units providing the robot with features like sensor fusion, attention, anticipation, and context-awareness.
Middleware-independence
The RUR platform does not prescribe how a cognitive architecture should be organized. Neither does it prescribe the communication infrastructure. The RUR platform is independent of the used middleware.

Programming code is separated into different components. For example a "particle filter", an "echo state network", a "reinforcement learning module", or other type of components that provide algorithms required for robotic applications. Each component is described in a language-independent manner using a well-known variant of the CORBA IDL, interface description language. An IDL is normally used to have a language neural interface between components, such that these can be written in multiple languages. Specific instances of IDLs (besides the CORBA one) are Protocol Buffers (Google), Avro (Hadoop, Apache), Thrift (Facebook, Apache), and WSDL (tailored to web services).

The RUR platform provides the glue using the IDL specification of a component to generate a language-specific header file, which can be used to use this component in a certain middleware. So, from an IDL specification, code is generated that allows a component written in C to be used on a robot running the YARP middleware. However, using this same IDL specification a component written in Java can be used within the JADE multi-agent system. Of course, if the programmer allows a component to be used from within Java or C - by SWIG e.g. - this will make it possible to use the same component in either programming language, but this is not the task of the RUR platform.

The RUR platform is similar to a recent effort, Genom3, generator of modules. However, contrary to Genom3 which decorates existing code with generic keywords that will be replaced by middleware-specific terms, the component code will not be touched by the RUR compiler. This means that the code is still compilable, syntax highlighting still works properly, and declarations and references can be found by the indexer (in e.g. Eclipse).

Design Cycle with RUR
The common design cycle is like this:
    Write an .idl file for your component, can be a new or existing component. The component can contain several files, say we have "esn.cpp".
    Run the RUR compiler in the middleware-agnostic mode. This provides a language-specific header file "rur_esn.h".
    We make the "esn.cpp" file network-aware by making use of the port, channels, message structs defined in the "rur_esn.h" file.
    Run the RUR compiler in a middleware-specific mode. For example we run a yarp server on the robot. The "rur_esn.h" file will now be rewritten by yarp-specific function calls. Nothing needs to be changed in the "esn.cpp" file.
    Run the RUR compiler for another type of middleware, e.g. ROS. Now instead of the function calls for yarp, the header file will contain code for ros.


IDL compiler
There are several IDL compilers, but not many of them are flexible enough to be used for the generation of customized stubs. Development of the promising Flick IDL compiler halted in 1999. One IDL compiler that allows for a user-customizable back-end is omniiddl. This is the omniORB IDL compiler which can be used in default mode, or indeed by customized at wish.

Example

The best way to understand how this works, is by an example, such as scripts/example_sum.sh 

You see "backend=" in this script. This is retrieved from "local.mk". Use "BACKEND=STANDARD" and a header file will be generated, namely example/sum/SumModule.h. You see that this contains only dummy entities. However, the SumModuleMain.cpp file can refer to the functions defined in SumModule.h and compiles fine. It is only functionally void. Then set it back to "BACKEND=YARP" in "local.mk" and you will find out that the same header file is now generated with different content. You should now compile it with the proper YARP libraries, and indicate to the linker that you want to use -lYARP_OS and -lYARP_init. If you compile and link you should now have a proper binary that is totally YARP compliant.

You can compile the component with YARP enabled by running "make" in the root directory. And you will find a binary "SumModule" in the build directory.

You can test this component by typing in different consoles:
  yarp server
  ./SumModule 
  yarp write /in /summodule/input0
  yarp read /out /summodule/output0

And now you can start to type in the console, where you wrote the "yarp write" command. Type one value at a time, e.g.: 23 and press enter. If you enter the following number, you will find out that the sum of the last two is displayed in the "yarp read" console.

In a simular way you can now compile with ROS enabled by setting "local.mk" to "BACKEND=ROS". Do not forget to generate the proper header files beforehand. I might automate this later.

For most recent information, anne@almende.com

Have fun!

